<!DOCTYPE html>

<head>
  <html lang="en">
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!--aca importamos la fuente del titulo de la pagina-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,500;0,700;1,200&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/barra.css" />
  <link rel="stylesheet" href="css/grid6.css" />

  <title>ANTICUERPO</title>
</head>

<body>
  <nav class="navbar">
    <div class="brand-title">
      <a href="index.html"> <img src="images/logo.png" alt="logo de la pagina" class="logo"></a>
    </div>
    <a href="#" class="toggle-button">
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>

    </a>
    <div class="navbar-links">
      <ul>
        <li><a href="math.html">MATH</a></li>
        <li><a href="articles.html">ARTICLES</a></li>
        <li><a href="tech.html">TECH</a></li>
      </ul>
    </div>
  </nav>

  <div class="titleText">
    <h1>ANTICUERPO</h1><br>
  </div>

  <img src="images/defector.jpg" alt="defector imagen cyberpunk cyborg" class="imagen-articulo">

  <div class="menu-capitulos" style="width:80%;">

  <h3><a href="#chapter-1">CHAPTER 1: Introduction to APIs</a></h3>
  <h3><a href="#chapter-2">CHAPTER 2: API Management</a></h3>
  <h3><a href="#chapter-3">CHAPTER 3: Designing a RESTful API Interface</a></h3>
  <h3><a href="#chapter-4">CHAPTER 4: API Documentation</a></h3>
  <h3><a href="#chapter-5">CHAPTER 5: API Patterns</a></h3>
     
  </div>

  <div class="texto" id="chapter-1">

    <h2>CHAPTER 1: Introduction to APIs</h2>


    <p class="pText">
      API stands for application programming interface. An API helps expose a business
      service or an enterprise asset to the developers building an application.
      An API is a software-to-software interface that defines the contract for applications to talk to each other over a
      network without user interaction.
      The contract defines the protocol, the input and output formats, and the underlying
      data types to be used for the software components to interact. It defines the functionality that is independent of
      the
      underlying implementation technologies of the component.</p>

    <img class="imagen-articulo"
      src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/282d654c-36cf-41ce-ab2e-d5fc9d62b1bf/dfab57y-ba581d49-255d-44b5-98d4-4a1027e35096.png/v1/fill/w_894,h_894,strp/vaporwave_cat_drinking_in_space_by_thecenters_dfab57y-pre.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTA4MCIsInBhdGgiOiJcL2ZcLzI4MmQ2NTRjLTM2Y2YtNDFjZS1hYjJlLWQ1ZmM5ZDYyYjFiZlwvZGZhYjU3eS1iYTU4MWQ0OS0yNTVkLTQ0YjUtOThkNC00YTEwMjdlMzUwOTYucG5nIiwid2lkdGgiOiI8PTEwODAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.syabmXNSrH45X-kjcF3TNtha1WxxnyBGxiE03NaO3fE"
      alt="gato vaporwave">

    <h3>The Evolution of APIs</h3>



    <p class="pText">
      The term API may mean different things to different people, depending on the context.
      There are APIs for operating systems, applications, and the Web. For example, Windows
      provides APIs that are used by system hardware and applications. When you copy text
      or a picture from Microsoft PowerPoint to Word, the APIs are at work.

      By the year 2006, web APIs are demonstrating the power of the Internet. They are
      being used to share content and made available to social networks. But they are still not
      considered fit for mainstream businesses. This year also marks the beginning of the cloud
      computing era.

      With cloud computing, web APIs witness their real power. APIs can now be
      used to deploy global infrastructure.

      By 2012—after the introduction of powerful smartphones, iPads, tablets, and the
      growth of Android and Windows Mobile, the need for APIs to provide resources to build
      apps has grown exponentially.
    <h3>APIs Are Different from Web Sites</h3>
    <p class="pText">Web sites publish information that can be consumed by a user, but web sites do not have
      contracts. The layout, content, and the look and feel of a web site can change without prior notice to users.
      An API, on the other hand, has a well-defined contract. Other applications depend
      on this contract to use it.</p>
    <h3>Defining an API and Its Characteristics</h3>
    <p class="pText">In technical terms, an API defines the contract of a software component in terms of the
      protocol, data format, and the endpoint for two computer applications to communicate
      with each other over a network.</p>
    <h3>Types of APIs</h3>
    <p class="pText">Broadly classifying, APIs can be divided into two types: public APIs and private APIs
      Since public
      APIs expose the back-end systems of an organization through the enterprise firewall that
      can be accessed by all, they are open doors for hackers to intrude into the system.

      Private APIs are behind the closed doors of your organization.
      How do you make an API private? One simple way is to host it on a public network
      but not publicize its existence and documentation to the developer community.</p>
    <h3>Examples of Popular APIs</h3>
    <p class="pText">The history of web APIs dates back to 2005. Since then, the growth in the number of APIs
      is exponential. ProgrammableWeb maintains a repository of public APIs and has more than 13,000 APIs under
      different
      categories.Facebook APIs provide a platform for building applications
      that can be used by a member of the Facebook community.
      Google APIs allow communication with Google services, such
      as Search, Translate, Gmail, Maps, social, and advertising.
      AccuWeather APIs provide subscribers with access to locationbased
      weather data via a simple RESTful web interface.
      Twitter provides three types of APIs: REST APIs, search APIs, and
      streaming APIs.</p>
    <h3>The Difference Between a Web Service and a Web API</h3>
    <p class="pText">Wikipedia defines a web service as “a method of communication between two electronic
      devices over a network”.
      Going by these definitions, a web API can be considered as a subset of a web service.
      SOAP (Simple Object Access Protocol) web services typically use HTTP as a transport protocol, although this is not
      mandatory. SOAP can be over JMS/FTP/SMTP or any layer 7 protocol.
      A web API is a special kind of web service, where the emphasis has been moving
      to a simpler RErepresentational State transfer (REST)
      So far web services have been synonymous to SOAP web services. With the advent
      of REST, web APIs have been commonly referred to as RESTful web services.
      In terms of performance, SOAP-based web services are heavyweight, requiring
      additional processing of extra SOAP elements in the payload. REST-based web services
      are simpler with lightweight</p>
    <h3>How Are APIs Different from SOA?</h3>
    <p class="pText">Many often ask what the difference between APIs and SOA is.
      SOA stands for service-oriented architecture. Its core concept is the notion of service.
      A service can be defined as “a logical representation of a repeatable activity that has a
      specific outcome.”
      From a technical perspective, APIs also share the same characteristics. But they
      are more open, developer centric, easily consumable, and support human-readable
      formats, such as JSON.
      Services are the means by which providers codify the base capabilities of their
      domains. APIs are the way in which those capabilities are repackaged, productized, and
      shared in an easy-to-use format.
      At a technology level, SOA is related to XML and SOAP, whereas APIs are related to
      REST and JSON.
      Keeping the technical differences aside, the real difference between SOA and APIs
      center on scope and governance.
      API technology focuses on the consumption of the back-end services created using
      SOA principles. Hence, APIs can be thought of as an evolution of SOA
      From a governance perspective, SOA is managed through a governance model that
      is more formal, heavyweight, and prescriptive in nature.

      <h3> The API Value Chain</h3>
      <p class="pText">The business asset marks the beginning of the API value chain.
      The value of the asset determines the success of the API. Exposing the assets to
      others should also benefit the owner.
      Once an asset has been identified, the next step is to create an API to expose the
      business assets.
      The app developers then assess the APIs and create apps using them.
      The apps created by the developers can be mobile apps or web apps.
      The end users are the final actor in the API value chain.</p>
    <h3>Business Models for APIs</h3>
    <p class="pText">APIs form the foundation of digital business.
      As APIs help to drive business agility, growth and open new channels for revenue,
      there are many business models for API exposure.</p>
    <center><button class="top-button"><a href="#top">Top</a></button></center>

  </div>






  <div class="textoAmarillo" id="chapter-2">
    <h2>CHAPTER 2:API Manamegent</h2>

    <img class="imagen-articulo" src="https://thumbs.gfycat.com/LimpBestFritillarybutterfly.webp"
      alt="imagen de androides">
    <h3>API Management</h3>
    <p class="pText">Customers today want to have access to enterprise data and services through a variety of digital
      devices and channels.An API management platform enables you to create, analyze, and manage APIs in a secure and
      scalable environment.API management capabilities can be delivered by any API management vendor in a public cloud
      as a hosted service or can be deployed on-premise in a private cloud.</p>
    <h3>Secure, Reliable, and Flexible Communication</h3>
    <p class="pText">APIs help digital apps to communicate with back-end services. Communication forms the core of APIs.
      Communication can use REST, SOAP, Plain Old XML (POX), or any other protocol of choice.</p>
    <h3>The API Gateway</h3>
    <p class="pText">An API gateway forms the heart of any API management solution that enables secure,flexible, and
      reliable communication between the back-end services and digital apps.</p>
    <h3>API Security</h3>
    <p class="pText">APIs provide access to valuable and protected data and assets.Therefore, security for
      APIs is of utmost importance to protect the underlying assets from unauthenticated and
      unauthorized access. Due to the programmatic nature of APIs and their accessibility
      over the public cloud, they are also prone to a different kind of threat attack.</p>
    <h3>API Traffic Management</h3>
    <p class="pText">Depending on the nature of data and services provided by the API, traffic management
      offers a different business value to different classes of customers.</p>
    <h3>Interface Translation</h3>
    <p class="pText">When an enterprise creates an API to expose its data and services, it needs to ensure that
      the API interface is intuitive enough for developers to easily use. APIs should be created
      with an API-First approach, which promotes API creation with a consumer focus.</p>
    <h3>Caching</h3>
    <p class="pText">Caching is a mechanism to optimize performance by responding to requests with static
      responses stored in-memory. An API proxy can store back-end responses that do not
      change frequently in memory.Similarly, some static data required for request processing may also be stored
      in-memory. Instead of referring to the main data source each time, such data can be
      retrieved from the cache for processing the request.</p>
    <h3>Service Routing</h3>
    <p class="pText">APIs need to route requests from consumers to the right back-end service providing the
      business functionality. There may be one more backend systems providing the backend
      functionality. Hence, the API management platform should be able to identify and route
      the request to the correct instance of the back-end.</p>
    <h3>Service Orchestration</h3>
    <p class="pText">In many scenarios, the API gateway may need to invoke multiple back-end services in a
      particular sequence or in parallel and then send an aggregated response to the client. This
      is known as service orchestration.</p>

    <img class="imagen-articulo" src="https://25.media.tumblr.com/tumblr_lugj06ZSgX1r4xjo2o1_500.gif" alt="gato gif 2">


    <h3>API Auditing, Logging and Analytics</h3>
    <p class="pText">Businesses need to have insight into the API program to justify and make the right
      investments to build the right APIs. They need to understand how an APIs is used, know
      who is using it, and see the value generated from it. With proper insight, business can
      then make decisions on how to enhance the business value either by changing the API or
      by enriching it. An API gateway should provide the capability to measure, monitor, and
      report API usage analytics.</p>
    <h3>API Analytics</h3>
    <p class="pText">Analytics provide you with information to make future decisions about your API. When
      you see an increase in API traffic, you need to know whether this indicates the success of
      your API program or whether it is being used in a malicious way, resulting in inflated traffic.
      How do you determine the adoption of your API? Is there an increased interest in your
      APIs within the developer community? Is there an increase in the number of apps built
      using your APIs? How has the performance of the APIs been in terms of response time and
      throughput? What are the different kinds of devices being used to access the APIs? How
      have the APIs been adopted across the globe? As an API provider and consumer, you need
      to know the answer to these questions and many others.</p>
    <h3>Activity Logging</h3>
    <p class="pText">Activity logging provides basic logging of API access, consumption, performance, and any
      exceptions. The platform should capture and provide information on who is using an API,
      what types of apps and devices the API are being called from, and which geographical
      region is the source of the API traffic. It should log the IP address of the clients, as well as
      the date and time when a request was received and the response was sent.</p>
    <h3>Developer Enablement for APIs</h3>
    <p class="pText">An API program cannot be successful without the active involvement of a developer
      community. Application developers use APIs to build mobile apps or to build a custom
      integration between two or more applications. Hence, developers need to know which
      APIs are available, what their functionalities are, and how they can be used. Developers
      should have a playground to experience and test APIs to effectively use them in their
      applications.</p>
    <h3>Developer Portal</h3>
    <p class="pText">A developer portal is a customized web site that allows an API provider to provide
      services to the developer community. It is essentially a content-management system
      that documents the APIs—their functionalities, interfaces, getting-started guides, terms
      of use, and much more.</p>
    <h3>API Catalog and Documentation</h3>
    <p class="pText">As an API provider, you need a platform to publicize and document your APIs. Developer
      enablement services should allow an API provider to publish a discoverable catalog of
      APIs. An API catalog is also sometimes referred to as an API registry.</p>
    <h3>Developer Support</h3>
    <p class="pText">Properly designed REST APIs are normally very intuitive for developers to understand. App
      developers can easily start using them for app development. Still, the API provider should
      provide resources that developers can use to build innovative apps. Good API documentation
      and accelerators in the form of test and development kits can help speed up the adoption of
      APIs. API documentation should not only describe the API interface, but must also provide
      how-to guides for interacting with the APIs.</p>
    <h3>Developer Onboarding</h3>
    <p class="pText">To start consuming the APIs, developers must register with the API provider to get access
      credentials. Developers can either sign up independently or as part of a company. The
      signup process should be simple and easy. Developers should be able to go through a
      self-registration process and view the APIs available from the API provider. Developers can
      then select an API product and register their apps to use it. After successful registration and
      approval, an API key is generated along with a secret to uniquely identify the app. The API
      key is also referred to as an app key or a client ID.</p>
    <h3>Community Management</h3>
    <p class="pText">App developers often like to know the views of other developers in the community.
      They may want to collaborate and share their API usage learnings and experiences
      with one another. Blogs and forums form a major part of collaboration and community
      management. Developers may share their experiences with API usage via blog posts;
      such posts may need to be moderated by the API provider before they become visible
      to everyone. An API provider may also create a blog to share updates and future plans
      with the API consumer community. Advice and best practices on API usage may also be
      shared on blogs and discussion forums.</p>
    <h3>API Creation</h3>
    <p class="pText">An API acts as a facade to interact with the back-end services. The API team should be
      able to design the REST interface for the API and create an API proxy to interact with the
      back-end services. An API proxy acts as a facade to securely expose the back-end services
      to its consumers. Policies attached in the flow paths of the API proxy should be able
      to implement security, traffic management, message translation, encryption, filtering,
      caching, orchestration, and routing.</p>
    <h3>API Publication</h3>
    <p class="pText">Once an API has been created, it must be published to an environment before it can be
      discovered and consumed. The API management platform must therefore provide tools
      that can be used to migrate the APIs from lower environments and deploy to production.</p>
    <h3>Version Management</h3>
    <p class="pText">APIs evolve over time with newer business requirements. Hence, managing multiple
      versions of an API to support existing consumers is an important capability that must be
      provided by the API management platform. Version management should also provide the
      ability to deprecate and retire older versions smoothly. When an API version is marked
      as deprecated, the existing consumers should be notified though deprecation warnings.
      Deprecated APIs may continue to serve traffic from existing consumers. However, new
      consumers should not be able to sign up to use deprecated APIs.</p>
    <h3>Change Notification</h3>
    <p class="pText">Changes to an API may adversely affect its consumers. Hence, consumers must be
      notified of any planned changes to the API. Developers using the APIs should be made
      aware of any changes to the API. The API management platform must therefore provide
      a mechanism to notify API consumers of any API upgrades or outages.</p>
    <h3>Issue Management</h3>
    <p class="pText">The API management platform should provide API consumers with the facility to log
      issues found in the APIs. App developers consuming APIs must be able to report any
      issues or shortcomings related to their APIs. They should be able to raise support tickets
      and seek help regarding API usage. The issues can be reported through the developer
      portal. The API management platform should provide the capability to integrate defects
      reporting and issue management capabilities in existing systems within the enterprise.</p>
      <center><button class="top-button"><a href="#top">Top</a></button></center>
    
  </div>

  <div class="textoBlanco" id="chapter-3">

    <h2>CHAPTER 3: Designing a RESTful API Interface</h2>

    
    <p class="pText">REST is an architectural style. It is not any strict standard but provides certain guidelines
      and constraints to be followed. Roy Fielding originally described these constraints in his
      doctoral dissertation and coined the name Representational State Transfer.REST relies on stateless, cacheable, and client-server communication protocols such
      as HTTP. By following the principles of REST and applying it to stateless protocols such as
      HTTP, developers can build API interfaces that can be used from any device or operating
      system.</p>
    <h3>REST Principles</h3>
    <p class="pText">REST is a set of design principles for building scalable web services. Roy Fielding
      described the following six constraints in his PhD dissertation for building a RESTful
      architecture:
    </p>
    <ul class="unordered-list">
      <li>Uniform interface</li>
      <li>Client-server</li>
      <li>Stateless</li>
      <li>Cache</li>
      <li>Layered system</li>
      <li>Code on demand</li>
     </ul>
    <h3>Uniform Interface</h3>
    <p class="pText">A uniform interface helps to define the communication contract between client and
      the server. It helps to decouple the architecture. Client and server applications can be
      developed independently as long as they abide by the interface. The interface defines the
      mechanism and format for interaction—where and how the client can access a server
      resource.</p>
    <h3>Client-Server</h3>
    <p class="pText">The client-server constraint builds a loosely coupled and scalable web architecture.
      As long as the client and the server follow a uniform interface, they can be developed
      independently, using any language or technology.</p>
    <h3>Stateless</h3>
    <p class="pText">Statelessness is one of the key principles of a RESTful service. It dictates that a web server
      is not required to remember the state of the client application. All relevant contextual
      information should be sent by the client application in the request to the server for all its
      interactions. The state information can be included as part of the URI as a variable or it
      can be included as a query parameter, header parameter, or in the body. Once the request
      is processed by the server, the updated state of the resource is sent back in the response
      via headers and the body.</p>
    <h3>Cache</h3>
    <p class="pText">Caching is yet another REST constraint that increases the scalability and overall
      performance of the server application. The cache may reside anywhere in the network
      path between the client and server. It can reside in the server, or an external location
      like the CDN, or inside the client application itself. By following the caching constraint,
      the server can specify if a particular response can be cached or not. If the response is
      cacheable, the server may specify the lifetime of the cached response. Based on the
      lifetime, the client can decide if it wants to use a cached response or make a separate
      request to get the live data.</p>
    <h3>Layered Systems</h3>
    <p class="pText">The layered system principle enables a network intermediary to be installed between the
      client app and the actual back-end server. The layered system can be a proxy or a gateway
      that acts as a facade for the back-end system. It can be used to implement security,
      caching, rate limiting, load balancing, and so forth. The client never gets to know if it is
      connected directly to the source of the service or to an intermediary. The caching and
      load balancing implemented on the intermediary node can improve the scalability of the
      system.</p>
    <h3>Code on Demand</h3>
    <p class="pText">The code-on-demand constraint enables a web server to transfer executable programs to
      a client. This constraint tends to establish a technology coupling between the client and
      the web server. The client must be able to understand and execute the code it downloads
      on demand from the server. This is the only optional constraint for the REST architectural
      style. Examples of code-on-demand are Java applets, scripts, plug-ins, and Flash.</p>
    <h3>Designing a RESTful API</h3>
    <p class="pText">Now that you understand the fundamentals of REST principles, let’s look at the various
      considerations for designing a REST API interface.
      A uniform interface is one of the fundamental principles of the RESTful architectural
      style. Web components interoperate consistently within the uniform interface’s four
      constraints, which Fielding identified as follows:</p>
     
      <ul class="unordered-list">
        <li>Identification of resources</li>
        <li>Manipulation of resources through representation</li>
        <li>Self-descriptive messages</li>
        <li>Hypermedia as the engine of application state (HATEOS)</li>
      </ul>
      <img src="https://cdna.artstation.com/p/assets/images/images/015/674/404/large/ella-moon-.jpg?1549212059&dl=1" alt="gato4" class="imagen-articulo">
    <h3>Identification of Resources</h3>
    <p class="pText">Before we can identify a resource, we need to understand what a resource is.
      A resource is any web-based concept that can be referenced by a unique identifier and
      manipulated via the uniform interface. While designing a REST API for a travel portal,
      your resources could be customer, reservation, ticket, hotel, flight, bus, car, and so forth.
      A resource can be a single entity or a collection of entities.A resource is identified by a URI (Uniform Resource Identifier). A URI provides the
      name and the network address of a resource.The resources themselves are conceptually separate from the representations that
      are returned to the client. For example, the resource may be residing in some database,
      but when the server responds to a request for a resource, it does not send the database
      itself; rather it responds with some representation of the resource that represents a record
      in the database. For example, the record of a resource instance may be represented
      in XML, JSON, or HTML format, when it is returned to the client.</p>
    <h3>Manipulation of Resources through Representation</h3>
    <p class="pText">Clients modify a representation of a resource. The same exact resource may be
      represented in different ways for different clients. For example, for a UI client, it might
      be represented in HTML format; whereas for application clients, it might be represented
      in either JSON or XML format. The representation is a way for clients to interact with the
      resource, but it is not the resource itself.</p>
    <h3>Self-Descriptive Messages</h3>
    <p class="pText">Each message (request/response) must be self-descriptive. That mean that the message may
      contain additional information to tell the recipient how to process it. Information such as
      format (JSON/XML), size, payload itself, and other metadata information included in the
      message can be used by the recipient for processing. An HTTP message provides headers to
      organize the various types of metadata into uniform fields. For example, Content-Type can
      he used to specify the format of the message; Content-Length can be used to specify the size
      of the payload. Many such HTTP headers can be included in the message to describe to the
      recipient on how they should process the message.</p>
    <h3>Hypermedia as the Engine of Application State
      (HATEOAS)</h3>
    <p class="pText">A resources’ state information may include links to other resources. These links provide
      information on what to do next and how to traverse through other related resources in
      a meaningful manner; for example, after getting information about the account, you
      may want to deposit, withdraw, or transfer money.The presence or absence of a link in a resource representation is an important part of
      resource’s current state.
      While designing a REST API interface, you should keep all of these constraints in
      mind. The next few sections look at how to build a REST API interface by following these
      constraints.</p>
    <h3>Resource Identifier Design Using URIs</h3>
    <p class="pText">In a RESTful API, designing the resource is one of the most important tasks for its success.
      A well-designed resource makes the API intuitive, simple to understand, and easy to use.
      Let’s look at some of the best practices for designing RESTful APIs.Every resource should have a meaningful name to identify itself. Name a resource using
      a noun as opposed to a verb or an action. The URI for the resource should refer to a
      thing rather than an action. Also CRUD function names should not be used in the URI
      or resource names; for example, while designing resource for a customer’s entity, the
      resource URI should be named /customers instead of /getCustomers.</p>
    <h3>Modelling Resources and Subresources</h3>
    <p class="pText">According to Roy Fielding’s dissertation a resource is “any concept that might be the
      target of an author’s hypertext reference must fit within the definition of a resource.” It can
      be single instance of an object or a collection of objects. Even business processes and
      capabilities can fit the definition of a resource according to Roy Fielding. Resources form
      the core of REST API design. The starting point of modelling resources is to analyze the
      current business domain and identify all the relevant objects in it that can be named. The
      focus for identifying resources and modelling them should be from the consumer’s point
      of view. It is important to select the right resources and model them at the right level of
      granularity.</p>
    <h3>Best Practices for Identifying REST API Resources</h3>
    <p class="pText">The following are some of the best practices for identifying resources for RESTful API
      design.</p>

      <ul class="unordered-list">
        <li>Resources should not be too fine grained because they lead to
          chatty communication between the consumer and the provider.
          Chatty communication degrades overall performance of the app
          that is using the API; hence, it should be avoided.</li>
        <li>Resources should not be too course grained because this leads to
          APIs that are too difficult to use and maintain.</li>
        <li>Resources should be designed such that they do not lead to
          migration of control flow business logic to the API consumer side;
          for example, if updates to the customer information requires
          multiple fields to be updated in a specific sequence that depends
          on some logic, then the API to update the customer information
          should be designed so that the client is not responsible for
          executing the required flow logic. The responsibility of executing
          the logic should lie with the resource server hosting the resource.
          Shifting the logic to the consumer side has the risk of putting the
          resource data in an inconsistent state, especially in the event of
          failure. Fine-grained APIs that perform CRUD operations may
          put the business logic on the client side, creating tight coupling
          between the API consumer and the provider. Any change in
          business logic at the provider end would require corresponding
          changes on the API consumer side. They may not be possible
          in many cases, where consumers do not want to make frequent
          changes to the applications on their side.</li>
        <li>Resource selection should be independent of the underlying
          domain implementation details. Hence, even a business
          process can be modelled as a resource if the process involves
          the operation of multiple low-level resources. For example, the
          process of setting up a customer in a bank may be modelled as
          a resource. So there can be a resource created for a customer
          account setup—such as /accountSetup—that needs to call
          operations on related resources for entities such as customer and
          account. By modeling a business process as a resource, the API
          consumer does not need to apply the business logic in the code.</li>
      </ul>


    <h3>URI Path Design</h3>
    <p class="pText">Every collection and resource in an API has its own URL. It is recommended to design
      URLs using an alternate combination of collection/resource path segments, relative to the
      API entry point.There may be arbitrary levels of nesting for subresources. However, it is
      recommended to limit the depth to two or three, if possible, because longer URLs are
      more difficult to work with.
      A URI design that follows a predictable pattern with a hierarchical approach
      to traverse through the resources eases developer adoption; for example, /stores/
      {storeId}/products/{productId}. This helps developers to guess the URI for a given
      resource; and hence, it can make direct calls without going through links.</p>
    <h3>URI Format</h3>
    <p class="pText">Let’s now look at the recommended format of a URI and learn how this format can be
      effectively used for designing an API. As per RFC 23964: “a Uniform Resource Identifier
      (URI) is a compact string of characters for identifying an abstract or physical resource.”
      This identifier can be realized in one of two ways: as a Uniform Resource Locator (URL)
      or a Uniform Resource Name (URN).</p>
      <center><button class="top-button"><a href="#top">Top</a></button></center>
     </div>

  <div class="texto" id="chapter-4">

    <h2>CHAPTER 4: API Documentation</h2>

    <img src="https://i.pinimg.com/originals/e6/4e/4a/e64e4af22d106f3edd7604570769c461.gif" alt="gato4" class="imagen-articulo">

    <p class="pText">Documenting a REST API is important for its successful adoption. APIs expose data
      and services that consumers want to use. An API should be designed with an interface
      that the consumer can understand. API documentation is key to the app developers
      comprehending the API. The documentation should help the developer to learn about
      the API functionality and enable them to start using it easily. This chapter looks at the
      aspects of documenting an API and some of the tools and technologies available for API
      documentation, including RAML, Swagger, API Blueprint, and others.</p>
    <h3>The Importance of API Documentation</h3>
    <p class="pText">As an API provider or developer, you may master your API. You have inside knowledge
      about its functionality, what it is supposed to do, how it is to be used, its security,
      limitations, error scenarios, and so forth. As an API provider, you have gradually learned
      everything about the API through various discussions, documentation, and references.
      However, this is not the case for the consumers of your API.As enterprises move along in the digital transformation journey, there has been
      exponential growth in public and private APIs. In this competitive world, it is very likely
      that the data and services exposed by your API may also be exposed by another API
      provider.The API documentation should</p>


      <ul class="unordered-list">
        <li>Get users started quickly</li>
        <li>Include useful and relevant information</li>
        <li>Provide sample code</li>
        <li>Document a list of REST endpoints</li>
        <li>Document the message payload</li>
        <li>Provide Response status code and error messages</li>
      </ul>


    <h3>Audience for API Documentation</h3>
    <p class="pText">API documentation is used by various groups of people for various reasons. It is like
      a user manual for a product. Like a user manual, API documentation should have a
      quick-start guide, which quickly makes the first API call and lets consumers have a feel
      of it.A good API document communicates all information about the usage of the API— for
      both humans and machines. The API document should provide all necessary information
      to app developers or API consumers in a human-readable format. The documentation
      should help them assess its suitability for use in their client app. It should provide
      information about its licensing policy and usage requirements-input and output
      parameters, message format, error messages, and more.</p>
    <h3>API Documentation Standards: Swagger, RAML,
      and API Blueprint</h3>
    <p class="pText">The daunting task of API documentation is keeping the documentation in sync with
      the actual implementation. If you take a bottom-up approach and create the API
      documentation manually after the implementation, you risk the documentation falling
      out of sync if there are enhancements to the API interface in the next version, especially
      if the process does not enforce regeneration or validation of the API document. Similarly,
      with a top-down approach, you may start with the API documentation and manually
      create the skeleton of the API interface according to the defined interface.There are many competing tools for API documentation. Some of them are in a fairly
      matured state, while others are still evolving. The next few sections look at the Swagger,
      RAML, and API Blueprint frameworks so that you can see how they are used to document
      an API interface. The tools that they provide are also discussed.</p>
    <h3>Swagger</h3>
    <p class="pText">Swagger is one of the most popular API documentation frameworks. It provides a
      standard, language-agnostic way of defining a REST API interface. This approach allows
      the client to understand the capabilities of the REST service without any prior access to the
      service implementation code or network inspection.An API’s Swagger specifications are documented in JSON or YAML format. Swaggerenabled
      APIs expose JSON files that adhere to the specifications. The API specification
      can be a manually generated static file or automatically generated from the application.The Swagger UI provides a framework to dynamically generate beautiful interactive
      documentation from a Swagger-compliant API. It is an independent collection of HTML,
      CSS, and JavaScript that can be hosted on any server. It can be used by consumers to
      explore and interact with the API and understand its behavior.</p>
    <h3>RAML</h3>
    <p class="pText">RAML stands for RESTful API Markup Language. It is a Markdown-based language for
      modeling APIs. It makes it easy to manage the entire lifecycle of an API: design, build,
      test, document, and share. RAML is both machine-readable and human friendly. RAML is
      designed to support an API-First top-down development approach. It provides the format
      for the contract between the API provider and the API consumer.</p>
    <h3>API Blueprint Document Structure</h3>
    <p class="pText">An API Blueprint document is structured into logical sections. For example, headers, URL
      parameters, and request/response can each be described in logically grouped sections.
      Each section is defined by predefined keywords. Depending on the section, the keyword
      is written either as a Markdown header entity or a list item entity.</p>
    <h3>Other API Documentation Frameworks</h3>
    <p class="pText">Swagger, RAML, and API Blueprint are the most popular API documentation standards.
      Most API management vendors include support (in various forms) in their tools for one
      or more of these languages. However, these specs are still evolving. In parallel, there have
      been efforts from various corners to create specs that address competitors’ shortcomings.
      As a result, many competing specs are available today from various vendors. These are in
      various levels of maturity.</p>
      <center><button class="top-button"><a href="#top">Top</a></button></center>
  </div>







  <div class="textoBlanco" id="chapter-5">
    <h2>CHAPTER 5: API Patterns</h2>
   
    <p class="pText">APIs should be designed for longevity. Any change to an API carries the risk of breaking
      the client’s application code. Frequent changes to an API frustrate the developers and
      the consumers using it. Building APIs from robust and proven patterns fosters a happy
      developer community and saves the company a lot of money. This chapter looks at
      some of the API design principles and patterns that have stood the test of time and make
      developers happy.</p>
      <img src="https://c.tenor.com/jIfa4bdSdxAAAAAC/cyberpunk.gif" alt="cyberpunk gif 2" class="imagen-articulo">
    <h3>Best Practices for Building a Pragmatic RESTful API</h3>
    <p class="pText">APIs are the face of your enterprise. They provide users with access to enterprise data,
      services, and assets. Hence, while security should be ingrained in it, the API interface
      should be simple and elegant to attract developers. It should be intuitive and developerfriendly
      to make adoption easy and pleasant.</p>
      <ul class="unordered-list">
        <li>Design APIs with RESTful URLs. Design an API based on the
          logical grouping of identified resources. The API URL should
          point to either a collection of resources/subresources or an
          individual entity within the collection.</li>
        <li>Use HTTP verbs for CRUD action on resources. Use the HTTP
          verbs to perform CRUD action on the resources. Use POST
          to create a new resource, GET to read, PUT to update, and
          DELETE to delete a resource. Additionally, you may consider
          providing support for the PATCH verb in the API resource for
          partial updates.</li>
        <li>Use operation in the URL when HTTP verb cannot map to
          the action. Often, an action on a resource cannot be directly
          mapped to an HTTP verb. For example, actions such as register,
          activate, and so forth, cannot be directly mapped to an HTTP
          verb.</li>
        <li>Use SSL/TLS for all communications with REST APIs. RESTful
          APIs expose enterprise data and assets. These can be accessed
          from within the company or from outside the firewall over the
          Internet from anywhere. This poses a security threat to the
          data transferred over the network.</li>
        <li>Do not redirect from non-SSL API endpoints to SSL endpoints.
          This is a practice to always avoid when designing REST APIs.
          Malicious clients may gain access to actual secured and encrypted
          API resources through such redirections.</li>
        <li>API versions. Versioning iterates and improves APIs by
          providing a smooth transition path. It supports multiple versions
          of the APIs simultaneously and provides time for clients to
          upgrade to new version and provider to retire the old version.</li>
          <li>Design the API interface to support filtering on the result
            set. The response to a GET request for an API resource may
            sometimes be quite large. Displaying this large response in
            the consumer app may be quite challenging considering the
            limited form factor and processing power on the device.</li>
          <li>Design the API to support pagination. Pagination is yet another
            feature that is useful in handling large responses from an API.
            Even the filtered response from the back-end service for an API
            may contain hundreds of records. In such a scenario, it makes
            sense to display only ten of them on a page in the consumer app
            and provide a link to the next page with the next set of records.</li>
          <li>Return resource representation in response to creating and
            updating. The response for POST, PUT, and PATCH operations
            results in creating and/or updating a resource. The API response
            payload for these methods should include metainformation
            such as 'created_at' or 'updated_at' along with the created
            or updated representation of the resource.</li>
            <li>Use HTTP headers to specify the media type for the message
              payload. When sending a request or a response, include the
              'Content-Type' header to specify the content type for the
              message payload. This helps the message recipient to easily
              identify the parser to be used for processing the message.</li>
            <li>Use HTTP headers to support caching. HTTP provides builtin
              features to support caching. HTTP provides a number of
              useful headers to efficiently communicate caching information.
              The 'ETag' header contains a hashed value of the resource
              information.</li>
            <li>Secure APIs using authentication information in HTTP
              header. APIs exposing data and assets should always be secured.
              Authentication credentials should be included in the HTTP
              Authorization header. Since REST services are stateless, cookies
              should not be used. Session information if any should be passed in
              custom HTTP headers.</li>
              <li>Handle Errors using HTTP Status code and appropriate error
                messages. In case of errors, APIs should respond with useful
                error messages in a consumable format. Appropriate HTTP
                error response codes in 4XX or 5XX series should be used.</li>
             
      </ul>

    <h3>API Management Patterns</h3>
    <p class="pText">Enterprise services provide access to assets and legacy systems. SOAP and REST APIs
      are the two most common implementation technologies used for building services. An
      API management platform is used to transform and manage these services to make them
      more flexible, scalable, and secure. Various implementation patterns have emerged to
      help address different challenges.</p>
    <h3>API Facade Pattern</h3>
    <p class="pText">The API facade pattern helps the API team create developer-friendly API designs and
      connect to complex enterprise legacy record systems.Back-end and internal system of records are often quite complex. They could be
      built using variety of technologies and sometimes even legacy ones. These are difficult to
      change due to the strong dependencies built over time and the complexity involved.Therefore flexibility and agility needed for the digital business becomes
      difficult to achieve. Creating an API for a single system of record may still be possible, but
      the real problem is in creating an API for a group of complementary systems that needs
      to be used to make an API really valuable to the developer. In this situation, API facade
      patterns come in handy for creating a simple API interface for a set of complex backend
      systems that are hard to change for digital transformation.</p>
    <h3>API Composition</h3>
    <p class="pText">Take for example that an app needs to interact with three different services for one of its
      transactions (see Figure 5-2). In this case, the client app has to be built so that it makes
      multiple calls directly to services, negotiates any security challenges, and does data
      format changes as required. With this approach, the client app is responsible for all the
      orchestration, data transformation and normalization, security, service connectivity, and
      retry mechanisms. This is indeed an overhead on the client app, considering the limited
      processing power available on the mobile devices. It is helpful for the developer building
      the app, if all these tasks can be off-loaded somewhere.Implementing the API composition pattern in the API facade layer can be a solution
      to this problem. With API composition, the developers can concentrate on the UI and
      business functionality. It makes the communication less chatty with reduced network
      calls between the app and the back-end services.Using an API gateway to implement the API facade pattern for composition is a
      common practice. An API gateway is a server that acts as a single point of entry into
      the system. It encapsulates the internal system architecture and provides an API that is
      customized for the client.</p>
    <h3>Session Management</h3>
    <p class="pText">API services should be designed to be stateless. But sometimes state management
      becomes necessary for designing an app with better user experience. Shopping cart, hotel
      booking are some examples where session management is necessary. Sessions maintain
      the client context on the server. In the API world, managing session information in the
      client apps running on devices is difficult. Devices are already constrained for memory
      and processing capacity. Hence, session management is an additional overhead, which
      can slowdown the overall performance.</p>
    <h3>Two-Phase Transaction Management</h3>
    <p class="pText">In a two-phase transaction, the transaction coordinator prepares the participating
      resources for a transaction in the first step. If the first step is successful, the commit is
      issued to the participating resources in the second step.Exposing each transaction phase as an API and expecting the client app to coordinate
      the transaction, and roll over in case of failure, is an over kill. Managing all transaction
      from the client app is going to result in a chatty conversation. The complex processing
      logic in the app for transaction coordination and management definitely yields a poor app
      performance. The solution is to handle the conversation from an API facade. The logic to
      prepare, commit, and roll back two-phase transaction management is implemented in the
      facade.booking service can expose only one endpoint to access it (/hotelbooking). This endpoint
      may in turn invoke two separate endpoints: one to reserve the hotel (/reserve) in the
      prepare phase and the second to make the payment (/payment) to confirm the
      reservation in the commit phase. This way the client need not directly access both
      /reserve and /payment services and nor does it have to manage the two-phase
      transaction.</p>
    <h3>Synchronous to Asynchronous Mediation</h3>
    <p class="pText">In many scenarios, the application client needs to access a back-end service that is long
      running and may not provide an immediate response. The mobile app cannot wait for
      the entire duration till the response is received. A typical example is sending a message.
      Suppose that you are building a mobile app that sends an SMS to a given number. After
      the message is sent, the mobile network takes its own time to deliver the message to the
      recipient depending on various factors. The message delivery status may be available
      almost immediately or after sometime depending on the network traffic and other factors.
      The back-end service is asynchronous. However, the mobile app expects a synchronous
      response. So how do you implement this? An API facade can provide a solution to this.
      Implementing a callback pattern on the API facade is the first step to this solution.</p>
    <h3>Routing</h3>
    <p class="pText">In a complex service composition scenario, the routing rules may not be fixed. The back
      end to which the request should be routed may have to be dynamically determined based
      on parameters in the incoming request. This is also known as content-based routing. The
      parameters for routing may be present in the request header or the message payload. In
      the API facade, these parameters are extracted and inspected to determine the back-end
      endpoint to which the request should be routed.</p>
      
    <h3>API Throttling</h3>
    <p class="pText">When an enterprise opens their API to the external world, it is expected to see an increase
      in the API traffic. Developers use these APIs to build new innovative apps. As more apps
      are built and adopted by users, the overall traffic is bound to increase. Also since the
      APIs are now open to the public, there may be some unexpected and unwanted load
      coming from some malicious apps, which may try to bring down the system. The current
      back-end systems may not have been designed to scale up and withstand this increased
      load. To maintain the performance and overall stability, it is important to maintain the
      overall traffic within the capacity limits of the back-end system by throttling the API.</p>

      <ul class="unordered-list">
        <li>Spike Arrest: With Spike Arrest, you can detect sudden
          unexpected changes to the traffic pattern. Applying a Spike
          Arrest policy smooths out the traffic by uniformly distributing the
          traffic across each smaller interval. For example, if the set spike
          arrest limit is 60 per minute, then only one request is allowed
          every second. If in any second there is more than one request,
          they would all be throttled. Similarly, if the spike arrest is 200
          per second, then only one request is allowed per 5 milliseconds.
          If there is more than one request in any 5-millisecond interval,
          subsequent requests is throttles. The value of the spike arrest
          should be calculated based on the capacity of the back-end
          services. The limits should be configured for shorter intervals
          such as sec or minutes. This feature protects the back-end
          services against sudden traffic burst coming from some malicious
          users or apps.</li>
        <li>Rate Limit or Quota: With a Rate Limiting approach (also
          sometime referred to as Quota), the requests are throttled based
          on the originating app or user, region of origination, time of the
          day and various other factors over a period of time. The request
          within the specified limit is routed successfully to the target
          system. Those beyond the limit are rejected.</li>
        <li>Concurrent back-end connections: Sometimes legacy backend
          systems might have the strict restrictions on the number
          of connections that can be made. By implementing throttling
          using concurrent connections, you can limit the number of
          simultaneous connections that can be made from the API to
          the back-end services at any given point of time.</li>
          </ul>
    <h3>Caching</h3>
    <p class="pText">Caching pattern can be used within an API gateway to cache backend responses or
      any information required for processing the request. When a client makes the same
      request, the cached response is returned to the client instead of forwarding the request
      to the back-end. This improves the overall API performance and improves the stability
      of the system by reducing the load on the back-end servers.</p>
    <h3>Logging and Monitoring</h3>
    <p class="pText">Logging is one of the best ways to identify and track problems. It is no different in the
      world of APIs. In fact, given the distributed nature of APIs, the importance of logging and
      monitoring increases significantly. To help identify problems during the processing of API
      requests, critical information should be logged. The information for logging should be
      collected at all stages of message processing and logged at the end of message processing
      or in the event of an error. Logging can be done to syslog or to a local file system. The
      ability to log to a local file system is generally available on a private cloud setup of API
      management platforms.The information logged should provide sufficient data to detect, find, and analyze
      the issue. Since APIs are used for distributed communication, log information should
      help locate the source of the issue. It should also provide information about the date/time
      of the issue, description of the issue with error codes and messages and a correlation ID
      to relate it to events in other applications of the system.</p>
      <img src="https://www.icegif.com/wp-content/uploads/2022/03/icegif-83.gif" alt="cyberpunk gif 1" class="imagen-articulo">
    <h3>API Analytics</h3>
    <p class="pText">Implementing APIs for digital transformation is not enough. You need visibility into
      your API program to measure the success and make strategic investments. API analytics
      provide insight into the API program through information about the API traffic pattern
      and performance metrics. An API analytics dashboard can tell you which APIs are used
      most frequently and how traffic varies over time. You can also get behavioral information
      about the target services in terms of response time, errors rates, size of the payload,
      and so forth. Information about the developer adoption of an API and the geographic
      distribution of API traffic can also be gathered from API analytics. Additionally, you
      can collect custom data from the message payloads and derive useful analytics data for
      making informed business decisions. Analytics data is normally stored in databases and
      later processed, aggregated, and analyzed. Hence, like the logging information, analytics
      data should also be collected at different points in the message flow and processed
      asynchronously to move it to the back-end database for dashboard reporting.</p>
    <h3>API Security Patterns</h3>
    <p class="pText">When APIs provide access to enterprise data and assets to a wide audience, they are
      also opening a larger variety of threats and security challenges for the company. The
      number of malicious assault and denial-of-service (DOS) attacks are increasing as APIs
      make back-end systems more accessible. Since APIs can be accessed programmatically,
      the vulnerability is even greater. Hence, over time, new security patterns have emerged
      to secure the access to APIs and protect back-end systems against various attacks. The
      challenge is in providing an easy access to legitimate and authorized users while making
      it difficult for unauthorized users to access APIs.</p>


    <h3>Common Forms of Attack</h3>
    <p class="pText">Hackers can attack to get access to the system, steal valuable information, or even bring
      down the system that impacts your business. The following are the most common forms
      of attack on APIs.</p>
      <ul class="unordered-list">
        <li>DoS attacks: Malicious users flood your system with high-volume
          API traffic that the back-end systems cannot handle, bringing it to
          a halt.</li>
        <li>Scripting attacks: In this kind of attack, attackers inject malicious
          code into the system to get access and possibly tamper back-end
          data and assets. The malicious code can be an SQL statement,
          XPath or XQuery statement, or some script that tries to exploit
          design flows in the system to get access to back-end data.</li>
        <li>Eavesdropping: In this kind of attack, the hacker gets access to an
          API request or response while the data is in transit over a nonsecure
          API communication channel. He can then manipulate the
          message and send it to the ultimate recipient.</li>
        <li>Session attack: In this kind of attack, the hackers gain access to
          the session ID used by a user or app. This information is then
          used for personification and access to the user’s account and
          resources. In this common form of attack, an app makes an API
          call and passes the credentials or session information in the
          header, that can provide access to the underlying assets. The risk
          is worse in scenarios that use a multiparty authentication scheme,
          such as OAuth, to grant permissions to a third party to access to
          access their private data.</li>
        <li>Cross-site scripting (XSS): This is a special form of
          scripting attack that takes advantage of known vulnerabilities
          in a web site or web application. An attacker injects a malicious
          link or code that is executed on the victim’s web browser. This
          form of attack bypasses the same-origin policy that requires
          everything on a web page to come from the same source. When a
          same-origin policy is not enforced, the attacker can inject a script
          or modify the web page to achieve their purpose. An XSS attack
          delivers tainted content to the API from a trusted source that has
          permissions to the system. Hence, the API must protect itself by
          validating the 'Origin' header in the request payload to check
          for the origin before allowing access to back-end resources.</li>
      </ul>


    <h3>API Risk Mitigation Best Practices</h3>
    <p class="pText">There are different approaches and patterns that have emerged to protect APIs from
      various forms of security threats and provide comprehensive security. The approaches
      for securing APIs should control access to APIs as well as monitor and limit API usage.
      Controlling access to an API should authenticate and authorize users or apps making
      API calls. It should also scan incoming messages for well-formedness and any potential
      threats in it. A monitoring approach should detect any sudden changes in the API traffic
      pattern and block the user from making calls.</p>


    <h3>Authentication and Authorization</h3>
    <p class="pText">Every app is associated with a unique API key. Hence, API key validation on
      an API management layer can help identify the app and thus control access to the APIs.
      Once an app has been identified and validated, the user using the app should be verified
      to validate the end user permissions to access an API resource.API keys identify the app. It is the responsibility of the app to store them securely
      and protect them from misuse. The app should encrypt the key and store it in a secure
      vault to prevent any misuse. HMAC-based encryption can be used for encrypting API
      keys. Also keys should be transmitted in encrypted form over the network using SSL for
      any authentication between the app and the API gateway.OAuth should be used as a mechanism to provide authorization to a third-party
      application for access to an end user resource on behalf of them. OAuth helps with
      granting authorization without the need to share user credentials. OAuth 2.0 uses SSL for
      all of its communications. Hence, all user and app information in the OAuth dance with
      the OAuth provider is secured in transit.</p>


    <h3>Protect Against Attacks</h3>
    <p class="pText">Since APIs expose a lot of valuable business data, they are prone to different kinds of
      attacks. API management platforms come with in-built features to detect and eliminate
      such attacks. These platforms provide configurable policies or assertions, which when
      activated or attached in the request pipeline, can detect attacks using malicious contents
      or malformed XML or JSON. Some API platforms can also detect virus signatures. Schema
      validation policies or threat detection policies attached in the request-processing pipeline
      can mitigate the risk of SQL injections, malicious code injection, and business logic or
      parameter attacks. CORS header validation protects against XSS attacks. IP whitelisting is
      another approach to reduce risk from untrusted sources.Preventing APIs against denial-of-service attacks is another important security
      consideration. Most API management platforms provide protection against DoS attacks
      using Spike Arrest and Quota policies. The Spike Arrest policy identifies unexpected surge
      in the API traffics and reject all requests exceeding the configured limit.Alerts should be sent if APIs are getting overloaded or any
      suspicious pattern of API calls is detected. Using rate limits and quota policies alongs
      with a licensing model that establishes a contractual obligation between the API provider
      and the consumer app and enforces payments for violation of contracts, can minimize
      the risk of DoS attacks.</p>


    <h3>Encrypt Message Exchanges</h3>
    <p class="pText">Often, message payloads sent in API calls contain sensitive information that can be the
      target for man-in-the-middle attacks. An API management platform sits in between the
      client app and the API service provider as an API gateway. All communication between
      the client app and the API service provider through the intermediate API gateway should
      be secured using SSL/TLS encryption by default. A two-way SSL
      between the client app and the API gateway also helps with client authentication. SSL
      should also be enforced for all communications between the API gateway and the
      back-end service. A pervasive security approach for encrypting data using SSL prevents
      against man-in-the-middle attacks.</p>


    <h3>Monitor, Audit, and Log API Traffic</h3>
    <p class="pText">The API management solution should monitor, log and analyze API traffic. It understands
      API usage patterns. An API provider is interested in knowing which is their most popular
      API operation, who is the most popular user of the API, what is the rate of growth of API
      consumers, what is the traffic pattern over a period of time. An insight into all of this
      information helps with planning the API extensions to strengthen API security.Logging and Auditing is also one of the major regulatory compliance
      requirement. Various national and industry-specific laws require minimum logging.
      Regulatory compliance requirements in financial industry mandate that you log certain
      API traffic information and make it available as part of the audit and compliance process.</p>


    <h3>Build API Security into the SDLC Process</h3>
    <p class="pText">API security is not possible without a comprehensive set of security policies and
      processes ingrained within the development life cycle of API development. API
      architects should plan to address security for APIs at the start of the API program. They
      should provide guidelines for authentication and authorization to make APIs secure.
      Policies to protect APIs against various forms for attacks and vulnerabilities should
      be defined as part of the security architecture and design. These security policies
      should be implemented and thoroughly tested during the development and testing
      phases. Penetration testing of APIs should be a mandatory step in the testing phase.
      Post deployment, APIs should be continuously monitored for any potential threats and
      performance issues that could potentially indicate any security incident.</p>


    <h3>Use a PCI-Compliant Infrastructure</h3>
    <p class="pText">PCI compliance specifications define a set of guidelines for handling credit card and
      other sensitive information during a transaction or at rest. The consortium of industries
      began in 2006 and includes payment card processing companies like Visa, Mastercard,
      JCB, and Discover. The PCI-DSS compliance requirements apply to all organizations
      that store, process, or transmit credit card or payment information. The intent of this
      specification is to protect card holder data and give confidence to the consumers that
      their sensitive information would not be misused. The following are the some of the
      important guidelines for PCI compliance.</p>
      <ul class="unordered-list">
        <li>Build and maintain a secure firewall. Do not use any default
          passwords.</li>     

        <li>Protect stored data and encrypt sensitive data in transit.</li>
        <li>All application and systems should be secured and protected
          against unauthorized access using strong access control
          measures.</li>
        <li>Anti-virus and vulnerability management programs should be
          kept updated.</li>
        <li>Monitor network access and test systems regularly.</li>
        <li>Maintain an information security policy.</li>
      </ul>


    <h3>API Deployment Patterns</h3>
    <p class="pText">APIs need to be deployed on a platform that is scalable and flexible. The platform should
      simplify API development and deployment. It should also enable the business to manage
      the entire API ecosystem. The platform should drive the customer reach of the APIs and
      support business growth. To meet all of these demands, most API platforms provide two
      deployment models: cloud and on-premise. The decision to choose the right deployment
      model would depend on the business needs. Let’s look at the characteristics of each
      deployment model.</p>
    <h3>Cloud Deployment</h3>
    <p class="pText">The cloud deployment of API gateways is hosted and managed by API platform providers
      on a public cloud, such as AWS or Azure. For example, the Apigee cloud instance is
      hosted on AWS. Cloud deployment provides customers with seamless product upgrades
      and improves the pace of innovation.</p>
      <ul class="unordered-list">
        <li>Higher reliability and availability: Cloud platforms provide
          clustered environments that are distributed across multiple data
          centers and regions. This mitigates the risk of data center and
          network outages, and increases the reliability and availability of
          the platform. The API platform vendor handles traffic fluctuations
          and makes capacity adjustments to meet the guaranteed SLA.</li>
        <li>Faster time to market: The cloud instances of the API platforms
          can be spun off almost immediately by the API vendors. This
          saves time and hassle of hardware procurement, setup, and
          configuration. The cloud instances are up and running very
          quickly thus reducing the overall time to market for the API
          program.</li>
        <li>Reduced capital and operational expenditure: Cloud
          deployments are generally available in a subscription model. You
          pay by usage like number of API calls. This avoids upfront capital
          expenditures and reduces ongoing in-house operational costs.</li>
        <li>Reduced management overhead: Letting the API vendor focus
          on the data center infrastructure helps enterprises focus on
          building their API services. The API platform provider takes
          care of management over heads of running and managing
          the data center. They address all availability and performance
          management of the underlying infrastructure. Software updates
          and fixes are rolled out seamlessly by the vendors. The API
          provider can focus on creating the API and its back end.</li>
        <li>Increased scalability and agility: The licensing for the cloud
          platforms are generally by API traffic volume. If the traffic
          increases, API providers only pay additional licensing fee for
          the increased traffic. They do not need to bother about capacity
          planning, procurement of hardware, installation, configuration,
          and training needs for the operations personnel. The platform
          vendor makes the required changes to provision the additional
          capacity requested. This makes cloud environments ideal for
          horizontal scaling to meet the increased demand.</li>
        <li>Regulatory compliance: Often regulatory compliance
          requirements come in the way of adoption for cloud-hosted
          solutions. But most of the leading API management vendors
          have achieved industry compliances for their cloud-hosted
          platforms and their products. PCI DSS for the payment industry
          and HIPAA for the health industry are the most common
          industry compliance requirements. Since the platform is already
          compliant to the industry standards, it helps the client to easily
          meet the PCI requirements for security and log management on
          the cloud and other industry compliances.</li>
       
      </ul>
    <h3>On-Premise Deployment</h3>
    <p class="pText">In an on-premise deployment model, the API provider purchases the software and
      takes the responsibility of setting up and running the entire platform in its data centers.
      The API provider takes up all the management overhead of installing, running, and
      maintaining the API platform. They are responsible for the hardware procurement,
      data center setup, and network configuration. The responsibility to monitor the API
      platform performance, deal with outages, update and manage software versions and
      capacity scaling lies with the API provider. Managing the entire API platform also needs
      additional training about the platform. Though there are initial challenges for setting up
      the on-premise infrstructure, following reasons can be the main drivers for on-premise
      deployment.</p>
      <ul class="unordered-list">
        <li>Enhanced security: With an on-premise deployment model, the
          API service provider has full control on the data security. They
          can manage where the under lying data stores would be present,
          how infrastructure and the data in it is secured, and who can have
          access to it. This also meets the increased security audit needs of
          the enterprise.</li>
        <li>Reduced network latency: Since the API gateway is installed
          within the enterprise’s network, it cuts down on multiple network
          hops. API providers may also plan to install the API gateways
          within the same network as the back-end services. This reduces the
          network latency and increases the overall performance of the APIs.</li>
        <li>Better management and control: On-premise versioning
          provides better management and control over performance and
          scaling. You can decide on the number of instances of the product
          components to be installed to support increased load. You have
          control over changes to the environment configuration, such as
          software and hardware upgrades.</li>
       
      </ul>

    <h3>APIs for Internal Application Integration</h3>
    <p class="pText">Enterprises use SOA for building services to achieve loose coupling and reusability.
      These services are used for internal application integration. SOAP and other protocols
      are used for integration. SOA provided the right level of security and governance, but
      faced with the challenge of making the services easily discoverable and consumable.With huge investments already placed in SOA services, and with many business
      processes built around them, companies are less likely to throw it all out to embrace
      REST APIs. Hence, building an API on a clean slate is a rare opportunity. APIs have to be
      built on top of the SOA services that expose the back-end services to make them more
      consumer-friendly.</p>

    <h3>APIs for Business Partner Integration</h3>

    <p class="pText">Enterprise have been consuming third-party APIs to simplify and expand business
      partnership. When APIs are used for B2B partner integration, they grow the business
      rapidly. APIs provide faster integration and an improved partner/customer experience.
      The technicalities of creating APIs for partner integration are not much different.
      However, they are more rigorous and have a commercial aspect tied to it. Instead of being
      open to all, they are available to a select list of business partners. The API consumers
      and providers are bound by the legal business contracts for the use of the APIs. These
      business contracts govern the service levels and other aspects of API delivery and
      consumption. Both API consumers and API providers are responsible for the success of
      an API program.</p>
    <h3>APIs for External Digital Consumers</h3>
    <p class="pText">APIs have been adopted by enterprises to accelerate digital transformation, increase
      customer reach and loyalty, and discover new streams of revenue. Companies can now
      expose their business assets and service to a larger community of developers with an easy
      to use and intuitive API interface.APIs exposed to external digital consumers need a platform that is interactive
      and provides proactive support to developer community. An API portal provides
      such a platform. It publishes information about the APIs that developers can use for
      building apps. Interactive API documentation, blogs, and forums help the developer
      determine the suitability of an API. It also fosters collaboration with a bigger community
      of developers.Externalization of APIs and collaboration with other developers build an ecosystem
      of innovation. It helps developers to share ideas and read about the experiences of others.
      It generates new and innovative ideas that otherwise would not have been possible. Many
      companies have seen a northbound trend in their API traffic due to the new experiences
      brought in by apps created by external developers using their APIs.</p>
    
    
    <h3>APIs for Mobile</h3>
    <p class="pText">Mobile apps have changed the way that humans interact with enterprises. Even though
      computing power is shifting from server rooms to mobile devices, mobile apps are
      still limited in resources and restricted by bandwidth. Hence, building a mobile app
      mandated a simpler interface that can be consumed easily. Also the interface should be
      such that it can be easily shared with developers to consume them in the apps. RESTful
      APIs have all of these characteristics, which make them popular for mobile consumption.
      The API provider should take into considerations the design, security and operational
      aspects of the API to make them suitable for mobile consumption. Additionally, caching
      should be looked as an alternative for improving performance and reducing chattiness.
      Instead of sending bulk payloads, paginations, filtering and other mechanisms should be
      supported to reduce processing overhead on the mobile app. Standard web API security
      protocols such as OAuth and OpenID Connect should be supported to secure APIs and
      make them suitable for mobile consumption.</p>


    <h3>APIs for IoT</h3>

    <p class="pText">
      The Internet of Things (IoT) refers to the network of devices, sensors, and actuators that
      communicate with each other over the Internet using API technologies to build a new
      customer experience. This refers to wearable devices such as iWatch, connected cars,
      connected sensors—such as Nest thermostats, intelligent bulbs—such as Philips Hue,
      and many others. It is estimated that by 2020 there will be 50 billion connected devices.
      APIs form the communication foundation for these connected devices. But the challenge
      is with the diverse and the newer communication protocols, such as MQTT, AMQT,
      XMPP, and many others that need to be supported by the API platform. A new generation
      of infrastructure powered by autoscalling capabilities, may also be needed in furture to
      support the scale of IoT communication traffic.</p>
    
   <center><button class="top-button"><a href="#top">Top</a></button></center>
   </div>

   <div class="grid-6">
       
    <div class="card">
     <img src="images/canvas.jpg" class="artist__img" alt="imagen of lucy Mckenzie">
     <h4>Lucy McKenzie</h4><br>
     
     <p class="parrafo2">McKenzie collaborates with other creatives regularly. Through her collaborations, she challenges the notion of authorship by pointing to the strength of collective actions. </p>
    </div>
           
            
    <div class="card">
     <img src="images/background.jpg" class="artist__img" alt="imagen of emily speed" >

     <h4>Emily Speed</h4><br>
          
     <p >Experience a new film installation by North West based artist Emily Speed. The film is inspired by Edwin Abbott’s 1884 novella Flatland, a satire of Victorian society, where all existence is limited to two dimensions and women are restricted to thin, straight lines. </p>
     </div>

     <div class="card">
       <img src="images/asia.jpg" class="artist__img" alt="Zahoor ul Akhlaq painting">
       <h4>Zahoor ul Akhlaq</h4><br>
       
       <p class="parrafo2">Such marks make the image oscillate back and forth, back into the process of miniature making and forward into a Modernist frame. The reverse gear refers to the initial stage of drawing exercises: an exquisitely laborious procedure whereby the miniature student spends hours, days and nights, simply drawing parallel lines into square inch boxes with the razor sharp point of an extra hard pencil. </p>
      </div>

      <div class="card">
       <img src="images/emily.jpg" class="artist__img" alt="imagen of emily speed" >

       <h4>Grief, Trauma, Love</h4><br>
            
       <p >And I love the kind of ongoing love affair, aesthetically and politically, between Black Americans and Puerto Ricans. There’s been so much synergy, especially in the Bronx, in East Harlem, Lower East Side, and parts of Brooklyn. And so in the mid-’70s, there were all these art collectives forming around Puerto Rican identity and really direct-action organizations.</p>
       </div>


       <div class="card">
         <img src="images/work.jpg" class="artist__img" alt="imagen of lucy Mckenzie">
         <h4>Love Your Work</h4><br>
         
         <p class="parrafo2">Can architecture and design write scenarios for the next generation of work? What will it take to anticipate and formulate work environments and experiences that are productive, humane, and ecologically responsible? “No Sweat” challenges designers to speculate on the spaces of work in an accelerated future, and to imagine a world in which a novel ethics of labor can emerge.</p>
        </div>


        <div class="card">
         <img src="images/harvard_design.png" class="artist__img" alt="imagen of lucy Mckenzie">
         <h4>Harvard Design</h4><br>
         
         <p class="parrafo2">Contemporary public space projects should address both the digital and the physical layer of a place. The two are becoming increasingly interconnected and dependent on each other. Designers should awaken to the opport­unities emerging from their interaction and develop new ways of working that challenge the existing professional conventions. </p>
        </div>

 </div><!--fin grid-->
  
  

  <script src="main.js"></script>


</body>

</html>