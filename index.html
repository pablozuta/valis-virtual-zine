<!DOCTYPE html>

<head>
  <html lang="en">
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!--aca importamos la fuente del titulo de la pagina-->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@600&display=swap" rel="stylesheet">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,500;0,700;1,200&display=swap"
    rel="stylesheet">
  <link rel="stylesheet" href="css/style.css" />
  <link rel="stylesheet" href="css/barra.css" />

  <title>ANTICUERPO</title>
</head>

<body>
  <nav class="navbar">
    <div class="brand-title">
      <a href="index.html"> <img src="images/logo.png" alt="logo de la pagina" class="logo"></a>
    </div>
    <a href="#" class="toggle-button">
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>
      <span class="bar"></span>

    </a>
    <div class="navbar-links">
      <ul>
        <li><a href="math.html">MATH</a></li>
        <li><a href="articles.html">ARTICLES</a></li>
        <li><a href="tech.html">TECH</a></li>
      </ul>
    </div>
  </nav>

  <div class="titleText">
    <h1>ANTICUERPO</h1><br>

  </div>

  <div class="texto">

    <h2>CHAPTER 1: Introduction to APIs</h2>


    <p class="pText">
      API stands for application programming interface. An API helps expose a business
      service or an enterprise asset to the developers building an application.
      An API is a software-to-software interface that defines the contract for applications to talk to each other over a
      network without user interaction.
      The contract defines the protocol, the input and output formats, and the underlying
      data types to be used for the software components to interact. It defines the functionality that is independent of
      the
      underlying implementation technologies of the component.</p>

    <img class="imagen-articulo"
      src="https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/282d654c-36cf-41ce-ab2e-d5fc9d62b1bf/dfab57y-ba581d49-255d-44b5-98d4-4a1027e35096.png/v1/fill/w_894,h_894,strp/vaporwave_cat_drinking_in_space_by_thecenters_dfab57y-pre.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7ImhlaWdodCI6Ijw9MTA4MCIsInBhdGgiOiJcL2ZcLzI4MmQ2NTRjLTM2Y2YtNDFjZS1hYjJlLWQ1ZmM5ZDYyYjFiZlwvZGZhYjU3eS1iYTU4MWQ0OS0yNTVkLTQ0YjUtOThkNC00YTEwMjdlMzUwOTYucG5nIiwid2lkdGgiOiI8PTEwODAifV1dLCJhdWQiOlsidXJuOnNlcnZpY2U6aW1hZ2Uub3BlcmF0aW9ucyJdfQ.syabmXNSrH45X-kjcF3TNtha1WxxnyBGxiE03NaO3fE"
      alt="gato vaporwave">

    <h3>The Evolution of APIs</h3>



    <p class="pText">
      The term API may mean different things to different people, depending on the context.
      There are APIs for operating systems, applications, and the Web. For example, Windows
      provides APIs that are used by system hardware and applications. When you copy text
      or a picture from Microsoft PowerPoint to Word, the APIs are at work.

      By the year 2006, web APIs are demonstrating the power of the Internet. They are
      being used to share content and made available to social networks. But they are still not
      considered fit for mainstream businesses. This year also marks the beginning of the cloud
      computing era.

      With cloud computing, web APIs witness their real power. APIs can now be
      used to deploy global infrastructure.

      By 2012—after the introduction of powerful smartphones, iPads, tablets, and the
      growth of Android and Windows Mobile, the need for APIs to provide resources to build
      apps has grown exponentially.
    <h3>APIs Are Different from Web Sites</h3>
    <p class="pText">Web sites publish information that can be consumed by a user, but web sites do not have
      contracts. The layout, content, and the look and feel of a web site can change without prior notice to users.
      An API, on the other hand, has a well-defined contract. Other applications depend
      on this contract to use it.</p>
    <h3>Defining an API and Its Characteristics</h3>
    <p class="pText">In technical terms, an API defines the contract of a software component in terms of the
      protocol, data format, and the endpoint for two computer applications to communicate
      with each other over a network.</p>
    <h3>Types of APIs</h3>
    <p class="pText">Broadly classifying, APIs can be divided into two types: public APIs and private APIs
      Since public
      APIs expose the back-end systems of an organization through the enterprise firewall that
      can be accessed by all, they are open doors for hackers to intrude into the system.

      Private APIs are behind the closed doors of your organization.
      How do you make an API private? One simple way is to host it on a public network
      but not publicize its existence and documentation to the developer community.</p>
    <h3>Examples of Popular APIs</h3>
    <p class="pText">The history of web APIs dates back to 2005. Since then, the growth in the number of APIs
      is exponential. ProgrammableWeb maintains a repository of public APIs and has more than 13,000 APIs under
      different
      categories.Facebook APIs provide a platform for building applications
      that can be used by a member of the Facebook community.
      Google APIs allow communication with Google services, such
      as Search, Translate, Gmail, Maps, social, and advertising.
      AccuWeather APIs provide subscribers with access to locationbased
      weather data via a simple RESTful web interface.
      Twitter provides three types of APIs: REST APIs, search APIs, and
      streaming APIs.</p>
    <h3>The Difference Between a Web Service and a Web API</h3>
    <p class="pText">Wikipedia defines a web service as “a method of communication between two electronic
      devices over a network”.
      Going by these definitions, a web API can be considered as a subset of a web service.
      SOAP (Simple Object Access Protocol) web services typically use HTTP as a transport protocol, although this is not
      mandatory. SOAP can be over JMS/FTP/SMTP or any layer 7 protocol.
      A web API is a special kind of web service, where the emphasis has been moving
      to a simpler RErepresentational State transfer (REST)
      So far web services have been synonymous to SOAP web services. With the advent
      of REST, web APIs have been commonly referred to as RESTful web services.
      In terms of performance, SOAP-based web services are heavyweight, requiring
      additional processing of extra SOAP elements in the payload. REST-based web services
      are simpler with lightweight</p>
    <h3>How Are APIs Different from SOA?</h3>
    <p class="pText">Many often ask what the difference between APIs and SOA is.
      SOA stands for service-oriented architecture. Its core concept is the notion of service.
      A service can be defined as “a logical representation of a repeatable activity that has a
      specific outcome.”
      From a technical perspective, APIs also share the same characteristics. But they
      are more open, developer centric, easily consumable, and support human-readable
      formats, such as JSON.
      Services are the means by which providers codify the base capabilities of their
      domains. APIs are the way in which those capabilities are repackaged, productized, and
      shared in an easy-to-use format.
      At a technology level, SOA is related to XML and SOAP, whereas APIs are related to
      REST and JSON.
      Keeping the technical differences aside, the real difference between SOA and APIs
      center on scope and governance.
      API technology focuses on the consumption of the back-end services created using
      SOA principles. Hence, APIs can be thought of as an evolution of SOA
      From a governance perspective, SOA is managed through a governance model that
      is more formal, heavyweight, and prescriptive in nature.

      ---The API Value Chain
      The business asset marks the beginning of the API value chain.
      The value of the asset determines the success of the API. Exposing the assets to
      others should also benefit the owner.
      Once an asset has been identified, the next step is to create an API to expose the
      business assets.
      The app developers then assess the APIs and create apps using them.
      The apps created by the developers can be mobile apps or web apps.
      The end users are the final actor in the API value chain.</p>
    <h3>Business Models for APIs</h3>
    <p class="pText">APIs form the foundation of digital business.
      As APIs help to drive business agility, growth and open new channels for revenue,
      there are many business models for API exposure.</p>

  </div>






  <div class="textoAmarillo">
    <h2>CHAPTER 2:API MANAGEMENT</h2>

    <img class="imagen-articulo" src="https://thumbs.gfycat.com/LimpBestFritillarybutterfly.webp"
      alt="imagen de androides">
    <h3>API Management</h3>
    <p class="pText">Customers today want to have access to enterprise data and services through a variety of digital
      devices and channels.An API management platform enables you to create, analyze, and manage APIs in a secure and
      scalable environment.API management capabilities can be delivered by any API management vendor in a public cloud
      as a hosted service or can be deployed on-premise in a private cloud.</p>
    <h3>Secure, Reliable, and Flexible Communication</h3>
    <p class="pText">APIs help digital apps to communicate with back-end services. Communication forms the core of APIs.
      Communication can use REST, SOAP, Plain Old XML (POX), or any other protocol of choice.</p>
    <h3>The API Gateway</h3>
    <p class="pText">An API gateway forms the heart of any API management solution that enables secure,flexible, and
      reliable communication between the back-end services and digital apps.</p>
    <h3>API Security</h3>
    <p class="pText">APIs provide access to valuable and protected data and assets.Therefore, security for
      APIs is of utmost importance to protect the underlying assets from unauthenticated and
      unauthorized access. Due to the programmatic nature of APIs and their accessibility
      over the public cloud, they are also prone to a different kind of threat attack.</p>
    <h3>API Traffic Management</h3>
    <p class="pText">Depending on the nature of data and services provided by the API, traffic management
      offers a different business value to different classes of customers.</p>
    <h3>Interface Translation</h3>
    <p class="pText">When an enterprise creates an API to expose its data and services, it needs to ensure that
      the API interface is intuitive enough for developers to easily use. APIs should be created
      with an API-First approach, which promotes API creation with a consumer focus.</p>
    <h3>Caching</h3>
    <p class="pText">Caching is a mechanism to optimize performance by responding to requests with static
      responses stored in-memory. An API proxy can store back-end responses that do not
      change frequently in memory.Similarly, some static data required for request processing may also be stored
      in-memory. Instead of referring to the main data source each time, such data can be
      retrieved from the cache for processing the request.</p>
    <h3>Service Routing</h3>
    <p class="pText">APIs need to route requests from consumers to the right back-end service providing the
      business functionality. There may be one more backend systems providing the backend
      functionality. Hence, the API management platform should be able to identify and route
      the request to the correct instance of the back-end.</p>
    <h3>Service Orchestration</h3>
    <p class="pText">In many scenarios, the API gateway may need to invoke multiple back-end services in a
      particular sequence or in parallel and then send an aggregated response to the client. This
      is known as service orchestration.</p>

    <img class="imagen-articulo" src="https://25.media.tumblr.com/tumblr_lugj06ZSgX1r4xjo2o1_500.gif" alt="gato gif 2">


    <h3>API Auditing, Logging and Analytics</h3>
    <p class="pText">Businesses need to have insight into the API program to justify and make the right
      investments to build the right APIs. They need to understand how an APIs is used, know
      who is using it, and see the value generated from it. With proper insight, business can
      then make decisions on how to enhance the business value either by changing the API or
      by enriching it. An API gateway should provide the capability to measure, monitor, and
      report API usage analytics.</p>
    <h3>API Analytics</h3>
    <p class="pText">Analytics provide you with information to make future decisions about your API. When
      you see an increase in API traffic, you need to know whether this indicates the success of
      your API program or whether it is being used in a malicious way, resulting in inflated traffic.
      How do you determine the adoption of your API? Is there an increased interest in your
      APIs within the developer community? Is there an increase in the number of apps built
      using your APIs? How has the performance of the APIs been in terms of response time and
      throughput? What are the different kinds of devices being used to access the APIs? How
      have the APIs been adopted across the globe? As an API provider and consumer, you need
      to know the answer to these questions and many others.</p>
    <h3>Activity Logging</h3>
    <p class="pText">Activity logging provides basic logging of API access, consumption, performance, and any
      exceptions. The platform should capture and provide information on who is using an API,
      what types of apps and devices the API are being called from, and which geographical
      region is the source of the API traffic. It should log the IP address of the clients, as well as
      the date and time when a request was received and the response was sent.</p>
    <h3>Developer Enablement for APIs</h3>
    <p class="pText">An API program cannot be successful without the active involvement of a developer
      community. Application developers use APIs to build mobile apps or to build a custom
      integration between two or more applications. Hence, developers need to know which
      APIs are available, what their functionalities are, and how they can be used. Developers
      should have a playground to experience and test APIs to effectively use them in their
      applications.</p>
    <h3>Developer Portal</h3>
    <p class="pText">A developer portal is a customized web site that allows an API provider to provide
      services to the developer community. It is essentially a content-management system
      that documents the APIs—their functionalities, interfaces, getting-started guides, terms
      of use, and much more.</p>
    <h3>API Catalog and Documentation</h3>
    <p class="pText">As an API provider, you need a platform to publicize and document your APIs. Developer
      enablement services should allow an API provider to publish a discoverable catalog of
      APIs. An API catalog is also sometimes referred to as an API registry.</p>
    <h3>Developer Support</h3>
    <p class="pText">Properly designed REST APIs are normally very intuitive for developers to understand. App
      developers can easily start using them for app development. Still, the API provider should
      provide resources that developers can use to build innovative apps. Good API documentation
      and accelerators in the form of test and development kits can help speed up the adoption of
      APIs. API documentation should not only describe the API interface, but must also provide
      how-to guides for interacting with the APIs.</p>
    <h3>Developer Onboarding</h3>
    <p class="pText">To start consuming the APIs, developers must register with the API provider to get access
      credentials. Developers can either sign up independently or as part of a company. The
      signup process should be simple and easy. Developers should be able to go through a
      self-registration process and view the APIs available from the API provider. Developers can
      then select an API product and register their apps to use it. After successful registration and
      approval, an API key is generated along with a secret to uniquely identify the app. The API
      key is also referred to as an app key or a client ID.</p>
    <h3>Community Management</h3>
    <p class="pText">App developers often like to know the views of other developers in the community.
      They may want to collaborate and share their API usage learnings and experiences
      with one another. Blogs and forums form a major part of collaboration and community
      management. Developers may share their experiences with API usage via blog posts;
      such posts may need to be moderated by the API provider before they become visible
      to everyone. An API provider may also create a blog to share updates and future plans
      with the API consumer community. Advice and best practices on API usage may also be
      shared on blogs and discussion forums.</p>
    <h3>API Creation</h3>
    <p class="pText">An API acts as a facade to interact with the back-end services. The API team should be
      able to design the REST interface for the API and create an API proxy to interact with the
      back-end services. An API proxy acts as a facade to securely expose the back-end services
      to its consumers. Policies attached in the flow paths of the API proxy should be able
      to implement security, traffic management, message translation, encryption, filtering,
      caching, orchestration, and routing.</p>
    <h3>API Publication</h3>
    <p class="pText">Once an API has been created, it must be published to an environment before it can be
      discovered and consumed. The API management platform must therefore provide tools
      that can be used to migrate the APIs from lower environments and deploy to production.</p>
    <h3>Version Management</h3>
    <p class="pText">APIs evolve over time with newer business requirements. Hence, managing multiple
      versions of an API to support existing consumers is an important capability that must be
      provided by the API management platform. Version management should also provide the
      ability to deprecate and retire older versions smoothly. When an API version is marked
      as deprecated, the existing consumers should be notified though deprecation warnings.
      Deprecated APIs may continue to serve traffic from existing consumers. However, new
      consumers should not be able to sign up to use deprecated APIs.</p>
    <h3>Change Notification</h3>
    <p class="pText">Changes to an API may adversely affect its consumers. Hence, consumers must be
      notified of any planned changes to the API. Developers using the APIs should be made
      aware of any changes to the API. The API management platform must therefore provide
      a mechanism to notify API consumers of any API upgrades or outages.</p>
    <h3>Issue Management</h3>
    <p class="pText">The API management platform should provide API consumers with the facility to log
      issues found in the APIs. App developers consuming APIs must be able to report any
      issues or shortcomings related to their APIs. They should be able to raise support tickets
      and seek help regarding API usage. The issues can be reported through the developer
      portal. The API management platform should provide the capability to integrate defects
      reporting and issue management capabilities in existing systems within the enterprise.</p>
    
  </div>

  <div class="textoBlanco">

    <h2>CHAPTER 3: Designing a RESTful API Interface</h2>

    
    <p class="pText">REST is an architectural style. It is not any strict standard but provides certain guidelines
      and constraints to be followed. Roy Fielding originally described these constraints in his
      doctoral dissertation and coined the name Representational State Transfer.REST relies on stateless, cacheable, and client-server communication protocols such
      as HTTP. By following the principles of REST and applying it to stateless protocols such as
      HTTP, developers can build API interfaces that can be used from any device or operating
      system.</p>
    <h3>REST Principles</h3>
    <p class="pText">REST is a set of design principles for building scalable web services. Roy Fielding
      described the following six constraints in his PhD dissertation for building a RESTful
      architecture:
    </p>
    <ul class="unordered-list">
      <li>Uniform interface</li>
      <li>Client-server</li>
      <li>Stateless</li>
      <li>Cache</li>
      <li>Layered system</li>
      <li>Code on demand</li>
     </ul>
    <h3>Uniform Interface</h3>
    <p class="pText">A uniform interface helps to define the communication contract between client and
      the server. It helps to decouple the architecture. Client and server applications can be
      developed independently as long as they abide by the interface. The interface defines the
      mechanism and format for interaction—where and how the client can access a server
      resource.</p>
    <h3>Client-Server</h3>
    <p class="pText">The client-server constraint builds a loosely coupled and scalable web architecture.
      As long as the client and the server follow a uniform interface, they can be developed
      independently, using any language or technology.</p>
    <h3>Stateless</h3>
    <p class="pText">Statelessness is one of the key principles of a RESTful service. It dictates that a web server
      is not required to remember the state of the client application. All relevant contextual
      information should be sent by the client application in the request to the server for all its
      interactions. The state information can be included as part of the URI as a variable or it
      can be included as a query parameter, header parameter, or in the body. Once the request
      is processed by the server, the updated state of the resource is sent back in the response
      via headers and the body.</p>
    <h3>Cache</h3>
    <p class="pText">Caching is yet another REST constraint that increases the scalability and overall
      performance of the server application. The cache may reside anywhere in the network
      path between the client and server. It can reside in the server, or an external location
      like the CDN, or inside the client application itself. By following the caching constraint,
      the server can specify if a particular response can be cached or not. If the response is
      cacheable, the server may specify the lifetime of the cached response. Based on the
      lifetime, the client can decide if it wants to use a cached response or make a separate
      request to get the live data.</p>
    <h3>Layered Systems</h3>
    <p class="pText">The layered system principle enables a network intermediary to be installed between the
      client app and the actual back-end server. The layered system can be a proxy or a gateway
      that acts as a facade for the back-end system. It can be used to implement security,
      caching, rate limiting, load balancing, and so forth. The client never gets to know if it is
      connected directly to the source of the service or to an intermediary. The caching and
      load balancing implemented on the intermediary node can improve the scalability of the
      system.</p>
    <h3>Code on Demand</h3>
    <p class="pText">The code-on-demand constraint enables a web server to transfer executable programs to
      a client. This constraint tends to establish a technology coupling between the client and
      the web server. The client must be able to understand and execute the code it downloads
      on demand from the server. This is the only optional constraint for the REST architectural
      style. Examples of code-on-demand are Java applets, scripts, plug-ins, and Flash.</p>
    <h3>Designing a RESTful API</h3>
    <p class="pText">Now that you understand the fundamentals of REST principles, let’s look at the various
      considerations for designing a REST API interface.
      A uniform interface is one of the fundamental principles of the RESTful architectural
      style. Web components interoperate consistently within the uniform interface’s four
      constraints, which Fielding identified as follows:</p>
     
      <ul class="unordered-list">
        <li>Identification of resources</li>
        <li>Manipulation of resources through representation</li>
        <li>Self-descriptive messages</li>
        <li>Hypermedia as the engine of application state (HATEOS)</li>
      </ul>
      <img src="https://cdna.artstation.com/p/assets/images/images/015/674/404/large/ella-moon-.jpg?1549212059&dl=1" alt="gato4" class="imagen-articulo">
    <h3>Identification of Resources</h3>
    <p class="pText">Before we can identify a resource, we need to understand what a resource is.
      A resource is any web-based concept that can be referenced by a unique identifier and
      manipulated via the uniform interface. While designing a REST API for a travel portal,
      your resources could be customer, reservation, ticket, hotel, flight, bus, car, and so forth.
      A resource can be a single entity or a collection of entities.A resource is identified by a URI (Uniform Resource Identifier). A URI provides the
      name and the network address of a resource.The resources themselves are conceptually separate from the representations that
      are returned to the client. For example, the resource may be residing in some database,
      but when the server responds to a request for a resource, it does not send the database
      itself; rather it responds with some representation of the resource that represents a record
      in the database. For example, the record of a resource instance may be represented
      in XML, JSON, or HTML format, when it is returned to the client.</p>
    <h3>Manipulation of Resources through Representation</h3>
    <p class="pText">Clients modify a representation of a resource. The same exact resource may be
      represented in different ways for different clients. For example, for a UI client, it might
      be represented in HTML format; whereas for application clients, it might be represented
      in either JSON or XML format. The representation is a way for clients to interact with the
      resource, but it is not the resource itself.</p>
    <h3>Self-Descriptive Messages</h3>
    <p class="pText">Each message (request/response) must be self-descriptive. That mean that the message may
      contain additional information to tell the recipient how to process it. Information such as
      format (JSON/XML), size, payload itself, and other metadata information included in the
      message can be used by the recipient for processing. An HTTP message provides headers to
      organize the various types of metadata into uniform fields. For example, Content-Type can
      he used to specify the format of the message; Content-Length can be used to specify the size
      of the payload. Many such HTTP headers can be included in the message to describe to the
      recipient on how they should process the message.</p>
    <h3>Hypermedia as the Engine of Application State
      (HATEOAS)</h3>
    <p class="pText">A resources’ state information may include links to other resources. These links provide
      information on what to do next and how to traverse through other related resources in
      a meaningful manner; for example, after getting information about the account, you
      may want to deposit, withdraw, or transfer money.The presence or absence of a link in a resource representation is an important part of
      resource’s current state.
      While designing a REST API interface, you should keep all of these constraints in
      mind. The next few sections look at how to build a REST API interface by following these
      constraints.</p>
    <h3>Resource Identifier Design Using URIs</h3>
    <p class="pText">In a RESTful API, designing the resource is one of the most important tasks for its success.
      A well-designed resource makes the API intuitive, simple to understand, and easy to use.
      Let’s look at some of the best practices for designing RESTful APIs.Every resource should have a meaningful name to identify itself. Name a resource using
      a noun as opposed to a verb or an action. The URI for the resource should refer to a
      thing rather than an action. Also CRUD function names should not be used in the URI
      or resource names; for example, while designing resource for a customer’s entity, the
      resource URI should be named /customers instead of /getCustomers.</p>
    <h3>Modelling Resources and Subresources</h3>
    <p class="pText">According to Roy Fielding’s dissertation a resource is “any concept that might be the
      target of an author’s hypertext reference must fit within the definition of a resource.” It can
      be single instance of an object or a collection of objects. Even business processes and
      capabilities can fit the definition of a resource according to Roy Fielding. Resources form
      the core of REST API design. The starting point of modelling resources is to analyze the
      current business domain and identify all the relevant objects in it that can be named. The
      focus for identifying resources and modelling them should be from the consumer’s point
      of view. It is important to select the right resources and model them at the right level of
      granularity.</p>
    <h3>Best Practices for Identifying REST API Resources</h3>
    <p class="pText">The following are some of the best practices for identifying resources for RESTful API
      design.</p>

      <ul class="unordered-list">
        <li>Resources should not be too fine grained because they lead to
          chatty communication between the consumer and the provider.
          Chatty communication degrades overall performance of the app
          that is using the API; hence, it should be avoided.</li>
        <li>Resources should not be too course grained because this leads to
          APIs that are too difficult to use and maintain.</li>
        <li>Resources should be designed such that they do not lead to
          migration of control flow business logic to the API consumer side;
          for example, if updates to the customer information requires
          multiple fields to be updated in a specific sequence that depends
          on some logic, then the API to update the customer information
          should be designed so that the client is not responsible for
          executing the required flow logic. The responsibility of executing
          the logic should lie with the resource server hosting the resource.
          Shifting the logic to the consumer side has the risk of putting the
          resource data in an inconsistent state, especially in the event of
          failure. Fine-grained APIs that perform CRUD operations may
          put the business logic on the client side, creating tight coupling
          between the API consumer and the provider. Any change in
          business logic at the provider end would require corresponding
          changes on the API consumer side. They may not be possible
          in many cases, where consumers do not want to make frequent
          changes to the applications on their side.</li>
        <li>Resource selection should be independent of the underlying
          domain implementation details. Hence, even a business
          process can be modelled as a resource if the process involves
          the operation of multiple low-level resources. For example, the
          process of setting up a customer in a bank may be modelled as
          a resource. So there can be a resource created for a customer
          account setup—such as /accountSetup—that needs to call
          operations on related resources for entities such as customer and
          account. By modeling a business process as a resource, the API
          consumer does not need to apply the business logic in the code.</li>
      </ul>


    <h3>URI Path Design</h3>
    <p class="pText">Every collection and resource in an API has its own URL. It is recommended to design
      URLs using an alternate combination of collection/resource path segments, relative to the
      API entry point.There may be arbitrary levels of nesting for subresources. However, it is
      recommended to limit the depth to two or three, if possible, because longer URLs are
      more difficult to work with.
      A URI design that follows a predictable pattern with a hierarchical approach
      to traverse through the resources eases developer adoption; for example, /stores/
      {storeId}/products/{productId}. This helps developers to guess the URI for a given
      resource; and hence, it can make direct calls without going through links.</p>
    <h3>URI Format</h3>
    <p class="pText">Let’s now look at the recommended format of a URI and learn how this format can be
      effectively used for designing an API. As per RFC 23964: “a Uniform Resource Identifier
      (URI) is a compact string of characters for identifying an abstract or physical resource.”
      This identifier can be realized in one of two ways: as a Uniform Resource Locator (URL)
      or a Uniform Resource Name (URN).</p>
     </div>

  <div class="texto">

    <h2>CHAPTER 4: API Documentation</h2>

    <img src="https://i.pinimg.com/originals/e6/4e/4a/e64e4af22d106f3edd7604570769c461.gif" alt="gato4" class="imagen-articulo">

    <p class="pText">Documenting a REST API is important for its successful adoption. APIs expose data
      and services that consumers want to use. An API should be designed with an interface
      that the consumer can understand. API documentation is key to the app developers
      comprehending the API. The documentation should help the developer to learn about
      the API functionality and enable them to start using it easily. This chapter looks at the
      aspects of documenting an API and some of the tools and technologies available for API
      documentation, including RAML, Swagger, API Blueprint, and others.</p>
    <h3>The Importance of API Documentation</h3>
    <p class="pText">As an API provider or developer, you may master your API. You have inside knowledge
      about its functionality, what it is supposed to do, how it is to be used, its security,
      limitations, error scenarios, and so forth. As an API provider, you have gradually learned
      everything about the API through various discussions, documentation, and references.
      However, this is not the case for the consumers of your API.As enterprises move along in the digital transformation journey, there has been
      exponential growth in public and private APIs. In this competitive world, it is very likely
      that the data and services exposed by your API may also be exposed by another API
      provider.The API documentation should</p>


      <ul class="unordered-list">
        <li>Get users started quickly</li>
        <li>Include useful and relevant information</li>
        <li>Provide sample code</li>
        <li>Document a list of REST endpoints</li>
        <li>Document the message payload</li>
        <li>Provide Response status code and error messages</li>
      </ul>


    <h3>Audience for API Documentation</h3>
    <p class="pText">API documentation is used by various groups of people for various reasons. It is like
      a user manual for a product. Like a user manual, API documentation should have a
      quick-start guide, which quickly makes the first API call and lets consumers have a feel
      of it.A good API document communicates all information about the usage of the API— for
      both humans and machines. The API document should provide all necessary information
      to app developers or API consumers in a human-readable format. The documentation
      should help them assess its suitability for use in their client app. It should provide
      information about its licensing policy and usage requirements-input and output
      parameters, message format, error messages, and more.</p>
    <h3>API Documentation Standards: Swagger, RAML,
      and API Blueprint</h3>
    <p class="pText">The daunting task of API documentation is keeping the documentation in sync with
      the actual implementation. If you take a bottom-up approach and create the API
      documentation manually after the implementation, you risk the documentation falling
      out of sync if there are enhancements to the API interface in the next version, especially
      if the process does not enforce regeneration or validation of the API document. Similarly,
      with a top-down approach, you may start with the API documentation and manually
      create the skeleton of the API interface according to the defined interface.There are many competing tools for API documentation. Some of them are in a fairly
      matured state, while others are still evolving. The next few sections look at the Swagger,
      RAML, and API Blueprint frameworks so that you can see how they are used to document
      an API interface. The tools that they provide are also discussed.</p>
    <h3>Swagger</h3>
    <p class="pText">Swagger is one of the most popular API documentation frameworks. It provides a
      standard, language-agnostic way of defining a REST API interface. This approach allows
      the client to understand the capabilities of the REST service without any prior access to the
      service implementation code or network inspection.An API’s Swagger specifications are documented in JSON or YAML format. Swaggerenabled
      APIs expose JSON files that adhere to the specifications. The API specification
      can be a manually generated static file or automatically generated from the application.The Swagger UI provides a framework to dynamically generate beautiful interactive
      documentation from a Swagger-compliant API. It is an independent collection of HTML,
      CSS, and JavaScript that can be hosted on any server. It can be used by consumers to
      explore and interact with the API and understand its behavior.</p>
    <h3>RAML</h3>
    <p class="pText">RAML stands for RESTful API Markup Language. It is a Markdown-based language for
      modeling APIs. It makes it easy to manage the entire lifecycle of an API: design, build,
      test, document, and share. RAML is both machine-readable and human friendly. RAML is
      designed to support an API-First top-down development approach. It provides the format
      for the contract between the API provider and the API consumer.</p>
    <h3>API Blueprint Document Structure</h3>
    <p class="pText">An API Blueprint document is structured into logical sections. For example, headers, URL
      parameters, and request/response can each be described in logically grouped sections.
      Each section is defined by predefined keywords. Depending on the section, the keyword
      is written either as a Markdown header entity or a list item entity.</p>
    <h3>Other API Documentation Frameworks</h3>
    <p class="pText">Swagger, RAML, and API Blueprint are the most popular API documentation standards.
      Most API management vendors include support (in various forms) in their tools for one
      or more of these languages. However, these specs are still evolving. In parallel, there have
      been efforts from various corners to create specs that address competitors’ shortcomings.
      As a result, many competing specs are available today from various vendors. These are in
      various levels of maturity.</p>

  </div>

  <script src="main.js"></script>


</body>

</html>